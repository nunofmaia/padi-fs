\subsection{Data Server}

Data servers store the content of one or more files. The content of each
file is stored using the local file system, in a local file with a
16-character ASCII string name generated by the metadata server. The
state and all files of the data server are written to disk.

Data servers store files with a version composed by a
monotonically increasing number, that starts with 0, and a timestamp.
The files also have a byte array with the content of the file.

\subsubsection{Communication with Metadata Servers}

The first action of a data server is to inform the metadata servers that
it is available to receive requests to store files. The metadata
server should register the data server as available and reply to it saying 
that the registration was successful. The data server waits for the
reply and if it does not receive any, it resends the message.

Servers receive a message from the primary metadata server in a regular
interval. This message is more like a request in the sense that data server
will answer this message with the number of accesses made to its files
for the purposes that we already mentioned when we talked about metadata
servers. But dispite of the statistical information sent to the metadata server that are
currently handling all the requests, this response is also useful for the metadata
server to know what are the data servers available.

%The data server receives a regular message, an heartbeat, from the primary
%metadata server. This way, the data server does not have to keep
%registered which metadata server is the primary.
%This heartbeat is useful for the primary metadata server to keep track of
%which servers are available to store new files and to avoid clients
%from waiting for data servers to come up to have a majority quorum.

We chose to give the responsibility to the metadata server of asking to
every data server if it is alive and wait for an answer because, in a large
system, the workload of the data servers will be higher compared to the
workload of the metadata servers. Data servers perform operations on larger
files. The exception is when multiple clients are making open and close
requests very intensively to the primary metadata server. Other approach
would be the data server to send an heartbeat to all metadata servers which,
during an intensive period of read and write requests and when the broadband
is critical, could clog the network since the data servers were sending two
messages that would be ignored by secondary metadata servers.
A third approach could be data servers to send the registry message to all
metadata servers and save the address of the server that answers which 
would be the primary metadata server. Further communications would be sent 
only to that server without receiving any answer. If the primary
metadata server fails, the new primary server would need to inform every data
server. This approach would rise the complexity level of the data and
metadata servers.

When the data server fails or freezes, it stops answering heartbeats from
the metadata servers. If the primary metadata server does not receive an
answer in a certain time, it believes the data server is unavailable
and this servers stops receiving requests from the metadata server to
create new files.

Each time the metadata server asks the data server to create a new file
with a given name, the data server tries to create the file and answers
to the metadata servers if the operation was successful or not.

The metadata server may request one data server to send a copy of one file
to another data server. This request is treated as any other request.
The data server that is going to copy the file asks the other data server
to write his version of the file. After writing the version it sends the 
confirmation to the other data server and this one sends back a response 
to the metadata server.
The data servers involved in the copy do not keep track of each other.

\subsubsection{Handling requests}

Clients ask data servers to read or write files. This requests are
processed as they arrive to the server without having any priority or 
reordering. It is simpler to buffer the requests as they arrive and to
perform them later.

Every file written in data servers have a version composed by a version
number that is incremented every time the file is written and a timestamp
from the last writing. This timestamp allows the data server to know if it is
receiving an earlier version than the version it has stored.

When the data server is requested to store a new version of the file, it has 
to check if this version is more recent than the version of the file it has 
stored. If it's not, the server discards the new file otherwise increments 
the version number and stores the file on disk. The data server always answers
to the client that it has received the file.

This solution raises the problem of destroying the previous work of other 
clients. When a client tries to write a file on disk, it does not know if 
another client read and wrote the same file after it has read its version. 
So, the newly written file may not have all the content written by the 
clients. To avoid this problem, we could implement a solution similar to 
distributed revision control systems but this would rise the complexity 
of the project.
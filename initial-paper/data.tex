\subsection{Data Server}

Data Servers store the content of one or more files. The content of each
file is stored using the local file system, in a local file with a
16-character ASCII string name generated by the Metadata Server. The
state and all files of the Data Server are written to disk.

Data Servers store files with a version composed by a
monotonically increasing number, that starts with 0, and a timestamp.
The files also have a byte array with the content of the file.

\subsubsection{Data Servers and Metadata Server}

The first action of a Data Server is to inform the Metadata Servers that
it is available to receive requests to store files from. The Metadata
Server should register the Data Server as available and reply to the Data
Server that the registration took success. The Data Server waits for the
reply and if it does not receive any, it resend the message. The secundary
Metadata Servers discard this message.

The Data Server sends a regular message, heart beat, to all the Metadata
Servers. The message is ignored by the two replicas, whether they are
available or not. This way, the Data Server does not have to keep
registered which Metadata Server is the primary and simplifies when
there was a change of primary Metadata Server, the Data Server does not
have to resend the message to the new primary.
This heart beat is useful to the primary Metadata Server keep track of
which servers are available to store new files and to avoid clients
from beeing waiting for Data Servers to come up to have a majority quorum.
We choose to not give the responsability to the Metadata Server of ask to
any Data Server if it is alive and wait for an answer because, in a large
system, the workload of the Data Servers will be lower compared to the
workload of the Metadata Servers. The exception is when multiple clients
are reading and writing intensively to the same few Data Servers. We
understood that this is an exception case. With this aproach, only one
message is sent from the Data Server to the Metadata Server trough the
network.

When the Data Server fails or freezes it stops sending heart beats to
the Metadata Servers. If the primary Metadata Server does not receive an
heart beat in a time window, it believes the Data Server is unavailable
and this servers stops receiving requests from de Metadata Server to
create new files.

Each time the Metadata Server asks the Data Server to create a new file
with a given name, the Data Server tries to create the new file and answers
to the Metadata Servers if the operation took success or not.

The Metadata Server may request one Data Server to send a copy of one file
to another Data Server. This request is treated as any other request.

\subsubsection{Reading and Writing to Data Servers}

Clients ask Data Servers to read or write files. This requests are
processed as they arrive to the server without having any priority neither
any reordering. It is simpler to buffer the requests as they arrive and to
perform them later.

Every file written in Data Servers have a version composed by a version
number that is incremented everytime the file is written and a timestamp
from the last writing. This timestamp let the Data Server to know if it is
receiving a version earlier than the version it stores.

When the Data Server is requested to store a new version of the file, it
checks if the new version is newer than the version that it stores, it
compares the timestamps and if it is earlier, it discards the version, else,
increments the version number of the file and stores it to disk.
This solution raises the problem of destroying the previous work of one
client when other, that read a previous file and edited it, asks the server
to write its version, overwriting the previous version, written by other
client, without updating its version with the content from the previous. To
avoid this, we could implement a solution similar to distributed revision
control systems, which would rise the complexity of the project.
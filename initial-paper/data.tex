\subsection{Data Server}

Data Servers store the content of one or more files. The content of each
file is stored using the local file system, in a local file with a
16-character ASCII string name generated by the Metadata Server. The
state and all files of the Data Server are written to disk.

Data Servers store files with a version composed by a
monotonically increasing number, that starts with 0, and a timestamp.
The files also have a byte array with the content of the file.

\subsubsection{Data Servers and Metadata Server}

The first action of a Data Server is to inform the Metadata Servers that
it is available to receive requests to store files from. The Metadata
Server should register the Data Server as available and reply to the Data
Server that the registration took success. The Data Server waits for the
reply and if it does not receive any, it resend the message. The secondary
Metadata Servers discard this message.

The Data Server receives a regular message, heart beat, from the primary
Metadata Server. This way, the Data Server does not have to keep
registered which Metadata Server is the primary
This heart beat is useful to the primary Metadata Server keep track of
which servers are available to store new files and to avoid clients
from being waiting for Data Servers to come up to have a majority quorum.

We choose to give the responsibility to the Metadata Server of ask to
every Data Server if it is alive and wait for an answer because, in a large
system, the workload of the Data Servers will be higher compared to the
workload of the Metadata Servers. The exception is when multiple clients
are opening and closing files intensively to the primary Metadata Server. We
understood that this is an exception case. Other approach would be the Data
Server send an heart beat to all Metadata Servers, which, in read/write
intensive operations, when the broadband is critical, could clog the network,
since the Data Servers were sending two messages that would be ignored by
secondary Metadata Servers.
A third approach could be Data Servers send the registry message to all
Metadata Servers and save who was the server that answered it and save the
address of the server as primary Metadata Server. Further communications
would be sent only to that server without receiving answer. If the primary
Metadata Server failed, the new primary would need to inform every Data
Server. This approach would rise the complexity level of the Data and
Metadata Servers.


When the Data Server fails or freezes it stops answering heart beats from
the Metadata Servers. If the primary Metadata Server does not receive an
answer in a time, it believes the Data Server is unavailable
and this servers stops receiving requests from the Metadata Server to
create new files.

Each time the Metadata Server asks the Data Server to create a new file
with a given name, the Data Server tries to create the new file and answers
to the Metadata Servers if the operation took success or not.

The Metadata Server may request one Data Server to send a copy of one file
to another Data Server. This request is treated as any other request.
The Data Server that is going to receive the new copy has already been
contacted by the Metadata Server to create the new file. The Data Server
that is going to copy the file, asks the other Data Server to write his
version of the file. Since the version number does not matter, this copy will
have a lower version number than the others. The Data Servers involved in the
copy does not keep track of each other.

\subsubsection{Reading and Writing to Data Servers}

Clients ask Data Servers to read or write files. This requests are
processed as they arrive to the server without having any priority neither
any reordering. It is simpler to buffer the requests as they arrive and to
perform them later.

Every file written in Data Servers have a version composed by a version
number that is incremented every time the file is written and a timestamp
from the last writing. This timestamp let the Data Server to know if it is
receiving a version earlier than the version it stores.

When the Data Server is requested to store a new version of the file, it
checks if the new version is newer than the version that it stores, it
compares the timestamps and if it is earlier, it discards the version, else,
increments the version number of the file and stores it to disk.
This solution raises the problem of destroying the previous work of one
client when other, that read a previous file and edited it, asks the server
to write its version, overwriting the previous version, written by other
client, without updating its version with the content from the previous. To
avoid this, we could implement a solution similar to distributed revision
control systems, which would rise the complexity of the project.